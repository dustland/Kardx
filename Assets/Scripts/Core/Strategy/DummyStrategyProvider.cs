using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Kardx.Utils;

namespace Kardx.Core.Strategy
{
  /// <summary>
  /// A dummy strategy provider that returns simple strategies for testing purposes.
  /// </summary>
  public class DummyStrategyProvider : IStrategyProvider
  {
    private readonly ILogger logger;
    private Player player;
    private Random random;

    /// <summary>
    /// Creates a new instance of the DummyStrategyProvider class.
    /// </summary>
    /// <param name="logger">Optional logger for debugging.</param>
    public DummyStrategyProvider(ILogger logger = null)
    {
      this.logger = logger;
      this.random = new Random();
    }

    /// <summary>
    /// Initializes the strategy provider with the player it represents.
    /// </summary>
    /// <param name="player">The player this provider represents.</param>
    public void Initialize(Player player)
    {
      this.player = player ?? throw new ArgumentNullException(nameof(player));
      logger?.Log($"[DummyStrategyProvider] Initialized for player {player.Id}");
    }

    /// <summary>
    /// Gets the next strategy for the player based on the current game state.
    /// </summary>
    /// <param name="board">The current game board.</param>
    /// <returns>A strategy containing a sequence of actions to execute.</returns>
    public async Task<Strategy> GetNextStrategyAsync(Board board)
    {
      if (board == null)
        throw new ArgumentNullException(nameof(board));

      if (player == null)
        throw new InvalidOperationException("Provider not initialized. Call Initialize first.");

      logger?.Log($"[DummyStrategyProvider] Generating simple strategy for player {player.Id}");

      // Simulate some processing time
      await Task.Delay(500);

      // Create a simple strategy
      var strategy = CreateSimpleStrategy(board);

      // Ensure the strategy ends with an end turn action
      EnsureEndTurnAction(strategy);

      logger?.Log($"[DummyStrategyProvider] Generated strategy with {strategy.Actions.Count} actions");
      return strategy;
    }

    /// <summary>
    /// Creates a simple strategy that makes the easiest valid moves with minimal decision-making.
    /// </summary>
    /// <param name="board">The current game board.</param>
    /// <returns>A simple strategy.</returns>
    private Strategy CreateSimpleStrategy(Board board)
    {
      var strategy = new Strategy("Simple strategy: Making the easiest valid moves")
      {
        Actions = new List<StrategyAction>()
      };

      // 1. Deploy the first playable card (if any)
      var playableCard = player.Hand
        .Where(c => c.DeploymentCost <= player.Credits)
        .FirstOrDefault();

      if (playableCard != null)
      {
        // Convert Guid to int using GetHashCode() since the Strategy methods expect int IDs
        strategy.AddDeployCardAction(playableCard.InstanceId.GetHashCode(), "Playing the first available card");
      }

      // 2. Attack with the first available card (if any)
      var opponent = (player.Id == board.Player.Id) ? board.Opponent : board.Player;
      if (opponent != null)
      {
        // Get the first non-null card on the battlefield
        var attackingCard = player.Battlefield
          .Where(c => c != null)
          .FirstOrDefault();

        if (attackingCard != null)
        {
          // Target: either the first opponent card or the opponent directly
          int targetId = 0; // Default to opponent (player)
          string reason = "Attacking opponent directly";

          var opponentCards = opponent.Battlefield.Where(c => c != null).ToList();
          if (opponentCards.Any())
          {
            var targetCard = opponentCards.First();
            // Convert Guid to int using GetHashCode() since the Strategy methods expect int IDs
            targetId = targetCard.InstanceId.GetHashCode();
            reason = $"Attacking the first available target";
          }

          // Convert Guid to int using GetHashCode() since the Strategy methods expect int IDs
          strategy.AddAttackAction(attackingCard.InstanceId.GetHashCode(), targetId, reason);
        }
      }

      return strategy;
    }

    /// <summary>
    /// Ensures that the strategy ends with an end turn action.
    /// </summary>
    /// <param name="strategy">The strategy to check and modify.</param>
    private void EnsureEndTurnAction(Strategy strategy)
    {
      // Use the built-in method in the Strategy class
      strategy.EnsureEndTurn();
    }
  }

  /// <summary>
  /// Enumerates the types of strategies that can be generated by the dummy provider.
  /// </summary>
  public enum StrategyType
  {
    /// <summary>
    /// Prioritizes attacking and dealing damage.
    /// </summary>
    [Obsolete("This strategy type is no longer used. The DummyStrategyProvider now uses a single simple strategy.")]
    Aggressive,

    /// <summary>
    /// Focuses on building defenses and maintaining board control.
    /// </summary>
    [Obsolete("This strategy type is no longer used. The DummyStrategyProvider now uses a single simple strategy.")]
    Defensive,

    /// <summary>
    /// A mix of aggressive and defensive actions.
    /// </summary>
    [Obsolete("This strategy type is no longer used. The DummyStrategyProvider now uses a single simple strategy.")]
    Balanced,

    /// <summary>
    /// Randomly selects actions.
    /// </summary>
    [Obsolete("This strategy type is no longer used. The DummyStrategyProvider now uses a single simple strategy.")]
    Random,

    /// <summary>
    /// Makes the simplest valid moves with minimal decision-making.
    /// </summary>
    Simple
  }
}